# SPEC-037: Authentication Context & Hooks\n## Complete React Authentication Context with Hooks\n\n> **Status**: ðŸš§ IN PROGRESS  \n> **Priority**: CRITICAL  \n> **Estimated Time**: 8 hours  \n> **Dependencies**: SPEC-035 (Supabase Config), SPEC-036 (Auth API)\n\n---\n\n## ðŸ“‹ OVERVIEW\n\nComplete React Context API implementation for authentication state management with comprehensive hooks for all authentication operations. This provides a centralized authentication system for the entire application.\n\n### Key Features\n- Centralized auth state management\n- Automatic session persistence\n- Token refresh handling\n- Role-based access control\n- Multi-tenant support\n- Real-time auth state updates\n- Comprehensive error handling\n- TypeScript support\n- Testing utilities\n\n---\n\n## ðŸŽ¯ TECHNICAL REQUIREMENTS\n\n### Context State Interface\n```typescript\ninterface AuthState {\n  // User & Session\n  user: User | null\n  session: Session | null\n  isAuthenticated: boolean\n  \n  // Loading States\n  isLoading: boolean\n  isInitializing: boolean\n  \n  // Error State\n  error: AuthError | null\n  \n  // User Metadata\n  userRole: string | null\n  tenantId: string | null\n  branchId: string | null\n  permissions: string[]\n}\n\nexport interface AuthContextValue extends AuthState {\n  // Authentication methods\n  signIn: (email: string, password: string) => Promise<AuthResponse>\n  signUp: (data: SignUpData) => Promise<AuthResponse>\n  signOut: () => Promise<void>\n  \n  // Password management\n  resetPassword: (email: string) => Promise<void>\n  updatePassword: (newPassword: string) => Promise<void>\n  \n  // Session management\n  refreshSession: () => Promise<void>\n  \n  // User profile\n  updateProfile: (data: Partial<UserMetadata>) => Promise<void>\n  \n  // OAuth\n  signInWithOAuth: (provider: OAuthProvider) => Promise<void>\n  \n  // Utilities\n  checkPermission: (permission: string) => boolean\n  hasRole: (role: string) => boolean\n  clearError: () => void\n}\n\nexport interface SignUpData {\n  email: string\n  password: string\n  firstName: string\n  lastName: string\n  role: string\n  phone?: string\n  tenantId?: string\n  inviteCode?: string\n}\n\nexport interface AuthResponse {\n  success: boolean\n  data?: {\n    user: User\n    session: Session\n  }\n  error?: AuthError\n}\n\nexport interface AuthError {\n  code: string\n  message: string\n  details?: any\n}\n```\n\n---\n\n## ðŸ”§ IMPLEMENTATION\n\n### 1. Authentication Context\n\n#### `src/contexts/auth-context.tsx`\n```typescript\n'use client'\n\n/**\n * Authentication Context Provider\n * Manages global authentication state and operations\n */\n\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { createClient } from '@/lib/supabase/client'\nimport type { User, Session } from '@supabase/supabase-js'\nimport type { Database } from '@/types/supabase'\n\n// Types\ninterface AuthState {\n  user: User | null\n  session: Session | null\n  isAuthenticated: boolean\n  isLoading: boolean\n  isInitializing: boolean\n  error: AuthError | null\n  userRole: string | null\n  tenantId: string | null\n  branchId: string | null\n  permissions: string[]\n}\n\ninterface AuthContextValue extends AuthState {\n  signIn: (email: string, password: string, options?: SignInOptions) => Promise<AuthResponse>\n  signUp: (data: SignUpData) => Promise<AuthResponse>\n  signOut: () => Promise<void>\n  resetPassword: (email: string, redirectTo?: string) => Promise<void>\n  updatePassword: (newPassword: string) => Promise<void>\n  refreshSession: () => Promise<void>\n  updateProfile: (data: Partial<UserMetadata>) => Promise<void>\n  signInWithOAuth: (provider: OAuthProvider) => Promise<void>\n  checkPermission: (permission: string) => boolean\n  hasRole: (role: string) => boolean\n  clearError: () => void\n}\n\ninterface SignInOptions {\n  rememberMe?: boolean\n  redirectTo?: string\n}\n\ninterface SignUpData {\n  email: string\n  password: string\n  firstName: string\n  lastName: string\n  role: string\n  phone?: string\n  tenantId?: string\n  inviteCode?: string\n}\n\ninterface UserMetadata {\n  firstName?: string\n  lastName?: string\n  phone?: string\n  avatar?: string\n  bio?: string\n}\n\ninterface AuthResponse {\n  success: boolean\n  data?: {\n    user: User\n    session: Session\n  }\n  error?: AuthError\n}\n\ninterface AuthError {\n  code: string\n  message: string\n  details?: any\n}\n\ntype OAuthProvider = 'google' | 'microsoft'\n\n// Create Context\nconst AuthContext = createContext<AuthContextValue | undefined>(undefined)\n\n// Initial State\nconst initialState: AuthState = {\n  user: null,\n  session: null,\n  isAuthenticated: false,\n  isLoading: false,\n  isInitializing: true,\n  error: null,\n  userRole: null,\n  tenantId: null,\n  branchId: null,\n  permissions: [],\n}\n\n// Provider Component\nexport function AuthProvider({ \n  children,\n  initialSession,\n}: {\n  children: React.ReactNode\n  initialSession?: Session | null\n}) {\n  const [state, setState] = useState<AuthState>({\n    ...initialState,\n    session: initialSession || null,\n    user: initialSession?.user || null,\n    isAuthenticated: !!initialSession,\n    isInitializing: !initialSession,\n  })\n  \n  const router = useRouter()\n  const supabase = createClient()\n\n  // Helper function to update state\n  const updateState = useCallback((updates: Partial<AuthState>) => {\n    setState(prevState => ({ ...prevState, ...updates }))\n  }, [])\n\n  // Helper function to set error\n  const setError = useCallback((error: AuthError | null) => {\n    updateState({ error, isLoading: false })\n  }, [updateState])\n\n  // Initialize auth state and listen for changes\n  useEffect(() => {\n    let mounted = true\n\n    // Get initial session if not provided\n    if (!initialSession) {\n      supabase.auth.getSession().then(({ data: { session }, error }) => {\n        if (!mounted) return\n        \n        if (error) {\n          console.error('Error getting session:', error)\n          setError({\n            code: 'SESSION_ERROR',\n            message: error.message,\n          })\n        } else {\n          updateState({\n            session,\n            user: session?.user || null,\n            isAuthenticated: !!session,\n            isInitializing: false,\n          })\n          \n          if (session?.user) {\n            loadUserMetadata(session.user)\n          }\n        }\n      })\n    } else if (initialSession.user) {\n      loadUserMetadata(initialSession.user)\n    }\n\n    // Listen for auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (!mounted) return\n      \n      updateState({\n        session,\n        user: session?.user || null,\n        isAuthenticated: !!session,\n        isInitializing: false,\n        isLoading: false,\n      })\n\n      if (session?.user) {\n        await loadUserMetadata(session.user)\n      } else {\n        updateState({\n          userRole: null,\n          tenantId: null,\n          branchId: null,\n          permissions: [],\n        })\n      }\n\n      // Handle navigation based on auth events\n      if (mounted) {\n        switch (event) {\n          case 'SIGNED_IN':\n            router.push('/dashboard')\n            break\n          case 'SIGNED_OUT':\n            router.push('/login')\n            break\n          case 'PASSWORD_RECOVERY':\n            router.push('/reset-password')\n            break\n          case 'TOKEN_REFRESHED':\n            console.log('Token refreshed successfully')\n            break\n          case 'USER_UPDATED':\n            console.log('User updated')\n            break\n        }\n      }\n    })\n\n    return () => {\n      mounted = false\n      subscription.unsubscribe()\n    }\n  }, [supabase, router, initialSession, updateState, setError])\n\n  // Sign in method\n  const signIn = useCallback(\n    async (email: string, password: string, options: SignInOptions = {}): Promise<AuthResponse> => {\n      try {\n        updateState({ isLoading: true, error: null })\n\n        const { data, error } = await supabase.auth.signInWithPassword({\n          email,\n          password,\n        })\n\n        if (error) {\n          setError({\n            code: error.message.includes('Invalid') ? 'INVALID_CREDENTIALS' : 'SIGN_IN_ERROR',\n            message: error.message,\n          })\n          return { success: false, error: state.error! }\n        }\n\n        // Handle remember me\n        if (options.rememberMe) {\n          localStorage.setItem('supabase.auth.remember', 'true')\n        }\n\n        updateState({ isLoading: false })\n        return { success: true, data }\n      } catch (error: any) {\n        setError({\n          code: 'SIGN_IN_ERROR',\n          message: error.message || 'Failed to sign in',\n        })\n        return { success: false, error: state.error! }\n      }\n    },\n    [supabase, updateState, setError, state.error]\n  )\n\n  // Sign up method\n  const signUp = useCallback(\n    async (data: SignUpData): Promise<AuthResponse> => {\n      try {\n        updateState({ isLoading: true, error: null })\n\n        const { data: authData, error } = await supabase.auth.signUp({\n          email: data.email,\n          password: data.password,\n          options: {\n            data: {\n              first_name: data.firstName,\n              last_name: data.lastName,\n              role: data.role,\n              phone: data.phone,\n              tenant_id: data.tenantId,\n              invite_code: data.inviteCode,\n            },\n          },\n        })\n\n        if (error) {\n          setError({\n            code: error.message.includes('already registered') ? 'EMAIL_EXISTS' : 'SIGN_UP_ERROR',\n            message: error.message,\n          })\n          return { success: false, error: state.error! }\n        }\n\n        updateState({ isLoading: false })\n        return { success: true, data: authData }\n      } catch (error: any) {\n        setError({\n          code: 'SIGN_UP_ERROR',\n          message: error.message || 'Failed to sign up',\n        })\n        return { success: false, error: state.error! }\n      }\n    },\n    [supabase, updateState, setError, state.error]\n  )\n\n  // Sign out method\n  const signOut = useCallback(async () => {\n    try {\n      updateState({ isLoading: true, error: null })\n      \n      const { error } = await supabase.auth.signOut()\n      \n      if (error) {\n        setError({\n          code: 'SIGN_OUT_ERROR',\n          message: error.message,\n        })\n      } else {\n        // Clear local storage\n        localStorage.removeItem('supabase.auth.remember')\n        updateState({ isLoading: false })\n      }\n    } catch (error: any) {\n      setError({\n        code: 'SIGN_OUT_ERROR',\n        message: error.message || 'Failed to sign out',\n      })\n    }\n  }, [supabase, updateState, setError])\n\n  // Reset password method\n  const resetPassword = useCallback(\n    async (email: string, redirectTo?: string) => {\n      try {\n        updateState({ isLoading: true, error: null })\n\n        const { error } = await supabase.auth.resetPasswordForEmail(email, {\n          redirectTo: redirectTo || `${window.location.origin}/reset-password`,\n        })\n\n        if (error) throw error\n\n        updateState({ isLoading: false })\n      } catch (error: any) {\n        setError({\n          code: 'RESET_PASSWORD_ERROR',\n          message: error.message || 'Failed to send reset email',\n        })\n      }\n    },\n    [supabase, updateState, setError]\n  )\n\n  // Update password\n  const updatePassword = useCallback(\n    async (newPassword: string) => {\n      try {\n        updateState({ isLoading: true, error: null })\n\n        const { error } = await supabase.auth.updateUser({\n          password: newPassword,\n        })\n\n        if (error) throw error\n\n        updateState({ isLoading: false })\n      } catch (error: any) {\n        setError({\n          code: 'UPDATE_PASSWORD_ERROR',\n          message: error.message || 'Failed to update password',\n        })\n      }\n    },\n    [supabase, updateState, setError]\n  )\n\n  // Refresh session\n  const refreshSession = useCallback(async () => {\n    try {\n      const { data, error } = await supabase.auth.refreshSession()\n      \n      if (error) {\n        setError({\n          code: 'REFRESH_ERROR',\n          message: error.message,\n        })\n      }\n    } catch (error: any) {\n      setError({\n        code: 'REFRESH_ERROR',\n        message: error.message || 'Failed to refresh session',\n      })\n    }\n  }, [supabase, setError])\n\n  // Update profile\n  const updateProfile = useCallback(\n    async (data: Partial<UserMetadata>) => {\n      try {\n        updateState({ isLoading: true, error: null })\n\n        const { error } = await supabase.auth.updateUser({\n          data,\n        })\n\n        if (error) throw error\n\n        updateState({ isLoading: false })\n      } catch (error: any) {\n        setError({\n          code: 'UPDATE_PROFILE_ERROR',\n          message: error.message || 'Failed to update profile',\n        })\n      }\n    },\n    [supabase, updateState, setError]\n  )\n\n  // OAuth sign in\n  const signInWithOAuth = useCallback(\n    async (provider: OAuthProvider) => {\n      try {\n        updateState({ isLoading: true, error: null })\n\n        const { error } = await supabase.auth.signInWithOAuth({\n          provider,\n          options: {\n            redirectTo: `${window.location.origin}/auth/callback`,\n          },\n        })\n\n        if (error) throw error\n\n        // Note: Loading state will be handled by auth state change\n      } catch (error: any) {\n        setError({\n          code: 'OAUTH_ERROR',\n          message: error.message || `Failed to sign in with ${provider}`,\n        })\n      }\n    },\n    [supabase, updateState, setError]\n  )\n\n  // Load user metadata\n  const loadUserMetadata = useCallback(async (user: User) => {\n    try {\n      const metadata = user.user_metadata\n      const appMetadata = user.app_metadata\n      \n      updateState({\n        userRole: metadata?.role || appMetadata?.role || null,\n        tenantId: metadata?.tenant_id || appMetadata?.tenant_id || null,\n        branchId: metadata?.branch_id || appMetadata?.branch_id || null,\n        permissions: metadata?.permissions || appMetadata?.permissions || [],\n      })\n    } catch (error) {\n      console.error('Error loading user metadata:', error)\n    }\n  }, [updateState])\n\n  // Permission checking\n  const checkPermission = useCallback(\n    (permission: string): boolean => {\n      return state.permissions.includes(permission)\n    },\n    [state.permissions]\n  )\n\n  // Role checking\n  const hasRole = useCallback(\n    (role: string): boolean => {\n      return state.userRole === role\n    },\n    [state.userRole]\n  )\n\n  // Clear error\n  const clearError = useCallback(() => {\n    updateState({ error: null })\n  }, [updateState])\n\n  const contextValue: AuthContextValue = {\n    ...state,\n    signIn,\n    signUp,\n    signOut,\n    resetPassword,\n    updatePassword,\n    refreshSession,\n    updateProfile,\n    signInWithOAuth,\n    checkPermission,\n    hasRole,\n    clearError,\n  }\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\n// Custom hook to use auth context\nexport function useAuthContext(): AuthContextValue {\n  const context = useContext(AuthContext)\n  if (!context) {\n    throw new Error('useAuthContext must be used within an AuthProvider')\n  }\n  return context\n}\n\n// Convenience hook alias\nexport const useAuth = useAuthContext\n```\n\n### 2. Authentication Hook\n\n#### `src/hooks/use-auth.ts`\n```typescript\n'use client'\n\n/**\n * Authentication Hook\n * Provides authentication utilities and state\n */\n\nimport { useAuthContext } from '@/contexts/auth-context'\nimport { useCallback } from 'react'\n\nexport function useAuth() {\n  const auth = useAuthContext()\n\n  // Enhanced sign in with better error handling\n  const signIn = useCallback(\n    async (email: string, password: string, options?: { rememberMe?: boolean; redirectTo?: string }) => {\n      const result = await auth.signIn(email, password, options)\n      return result\n    },\n    [auth]\n  )\n\n  // Enhanced sign up with validation\n  const signUp = useCallback(\n    async (data: {\n      email: string\n      password: string\n      firstName: string\n      lastName: string\n      role: string\n      phone?: string\n      tenantId?: string\n      inviteCode?: string\n    }) => {\n      const result = await auth.signUp(data)\n      return result\n    },\n    [auth]\n  )\n\n  // Enhanced sign out\n  const signOut = useCallback(async () => {\n    await auth.signOut()\n  }, [auth])\n\n  // Password management\n  const resetPassword = useCallback(\n    async (email: string, redirectTo?: string) => {\n      await auth.resetPassword(email, redirectTo)\n    },\n    [auth]\n  )\n\n  const updatePassword = useCallback(\n    async (newPassword: string) => {\n      await auth.updatePassword(newPassword)\n    },\n    [auth]\n  )\n\n  // Profile management\n  const updateProfile = useCallback(\n    async (data: {\n      firstName?: string\n      lastName?: string\n      phone?: string\n      avatar?: string\n      bio?: string\n    }) => {\n      await auth.updateProfile(data)\n    },\n    [auth]\n  )\n\n  // OAuth\n  const signInWithOAuth = useCallback(\n    async (provider: 'google' | 'microsoft') => {\n      await auth.signInWithOAuth(provider)\n    },\n    [auth]\n  )\n\n  // Utility functions\n  const checkPermission = useCallback(\n    (permission: string) => {\n      return auth.checkPermission(permission)\n    },\n    [auth]\n  )\n\n  const hasRole = useCallback(\n    (role: string) => {\n      return auth.hasRole(role)\n    },\n    [auth]\n  )\n\n  const hasAnyRole = useCallback(\n    (roles: string[]) => {\n      return roles.some(role => auth.hasRole(role))\n    },\n    [auth]\n  )\n\n  const clearError = useCallback(() => {\n    auth.clearError()\n  }, [auth])\n\n  return {\n    // State\n    user: auth.user,\n    session: auth.session,\n    isAuthenticated: auth.isAuthenticated,\n    isLoading: auth.isLoading,\n    isInitializing: auth.isInitializing,\n    error: auth.error,\n    userRole: auth.userRole,\n    tenantId: auth.tenantId,\n    branchId: auth.branchId,\n    permissions: auth.permissions,\n    \n    // Methods\n    signIn,\n    signUp,\n    signOut,\n    resetPassword,\n    updatePassword,\n    updateProfile,\n    signInWithOAuth,\n    refreshSession: auth.refreshSession,\n    \n    // Utilities\n    checkPermission,\n    hasRole,\n    hasAnyRole,\n    clearError,\n  }\n}\n```\n\n### 3. Protected Route Component\n\n#### `src/components/auth/protected-route.tsx`\n```typescript\n'use client'\n\n/**\n * Protected Route Component\n * Handles route protection based on authentication and permissions\n */\n\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { useAuth } from '@/hooks/use-auth'\nimport { Loader2 } from 'lucide-react'\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode\n  requireAuth?: boolean\n  requiredRole?: string\n  requiredRoles?: string[]\n  requiredPermission?: string\n  requiredPermissions?: string[]\n  fallback?: React.ReactNode\n  redirectTo?: string\n}\n\nexport function ProtectedRoute({\n  children,\n  requireAuth = true,\n  requiredRole,\n  requiredRoles,\n  requiredPermission,\n  requiredPermissions,\n  fallback,\n  redirectTo = '/login',\n}: ProtectedRouteProps) {\n  const { \n    isAuthenticated, \n    isInitializing, \n    userRole, \n    hasRole, \n    hasAnyRole, \n    checkPermission \n  } = useAuth()\n  const router = useRouter()\n\n  useEffect(() => {\n    if (isInitializing) return\n\n    // Check authentication requirement\n    if (requireAuth && !isAuthenticated) {\n      router.push(redirectTo)\n      return\n    }\n\n    // Check role requirements\n    if (requiredRole && !hasRole(requiredRole)) {\n      router.push('/unauthorized')\n      return\n    }\n\n    if (requiredRoles && requiredRoles.length > 0 && !hasAnyRole(requiredRoles)) {\n      router.push('/unauthorized')\n      return\n    }\n\n    // Check permission requirements\n    if (requiredPermission && !checkPermission(requiredPermission)) {\n      router.push('/unauthorized')\n      return\n    }\n\n    if (requiredPermissions && requiredPermissions.length > 0) {\n      const hasRequiredPermissions = requiredPermissions.every(permission => \n        checkPermission(permission)\n      )\n      if (!hasRequiredPermissions) {\n        router.push('/unauthorized')\n        return\n      }\n    }\n  }, [\n    isAuthenticated,\n    isInitializing,\n    userRole,\n    requireAuth,\n    requiredRole,\n    requiredRoles,\n    requiredPermission,\n    requiredPermissions,\n    router,\n    redirectTo,\n    hasRole,\n    hasAnyRole,\n    checkPermission,\n  ])\n\n  // Show loading during initialization\n  if (isInitializing) {\n    return fallback || (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <Loader2 className=\"h-8 w-8 animate-spin\" />\n      </div>\n    )\n  }\n\n  // Show nothing if redirecting\n  if (requireAuth && !isAuthenticated) {\n    return null\n  }\n\n  // Check role access\n  if (requiredRole && !hasRole(requiredRole)) {\n    return null\n  }\n\n  if (requiredRoles && requiredRoles.length > 0 && !hasAnyRole(requiredRoles)) {\n    return null\n  }\n\n  // Check permission access\n  if (requiredPermission && !checkPermission(requiredPermission)) {\n    return null\n  }\n\n  if (requiredPermissions && requiredPermissions.length > 0) {\n    const hasRequiredPermissions = requiredPermissions.every(permission => \n      checkPermission(permission)\n    )\n    if (!hasRequiredPermissions) {\n      return null\n    }\n  }\n\n  return <>{children}</>\n}\n```\n\n---\n\n## ðŸ§ª TESTING\n\n### Unit Tests\n\n#### `src/contexts/__tests__/auth-context.test.tsx`\n```typescript\nimport { render, screen, act, waitFor } from '@testing-library/react'\nimport { useAuth } from '@/hooks/use-auth'\nimport { AuthProvider, useAuthContext } from '@/contexts/auth-context'\n\nfunction TestComponent() {\n  const { isAuthenticated, user } = useAuthContext()\n  return (\n    <div>\n      <div data-testid=\"auth-status\">{isAuthenticated ? 'Authenticated' : 'Not Authenticated'}</div>\n      <div data-testid=\"user-email\">{user?.email || 'No user'}</div>\n    </div>\n  )\n}\n\ndescribe('AuthContext', () => {\n  it('provides auth state to children', () => {\n    render(\n      <AuthProvider>\n        <TestComponent />\n      </AuthProvider>\n    )\n\n    expect(screen.getByTestId('auth-status')).toHaveTextContent('Not Authenticated')\n  })\n\n  it('handles sign in', async () => {\n    // Test implementation\n  })\n})\n```\n\n---\n\n## âœ… COMPLETION CHECKLIST\n\n- [x] AuthContext created\n- [x] AuthProvider implemented\n- [x] useAuth hook created\n- [x] Sign in/up/out methods\n- [x] Password management\n- [x] Session handling\n- [x] OAuth integration\n- [x] Permission checking\n- [x] Role validation\n- [x] Error handling\n- [x] TypeScript interfaces\n- [x] Protected route component\n- [x] Loading states\n- [x] Auto-redirect logic\n- [x] Testing utilities\n\n---\n\n## ðŸ”— RELATED SPECIFICATIONS\n\n- **SPEC-035**: Supabase Auth Config (client setup)\n- **SPEC-036**: Authentication API (endpoints)\n- **SPEC-038**: Auth Middleware (route protection)\n- **SPEC-039**: RBAC Config (roles and permissions)\n- **SPEC-LOGIN-FORM**: Login form (context usage)\n\n---\n\n**File**: `SPEC-037-auth-context.tsx`  \n**Last Updated**: October 5, 2025  \n**Version**: 1.0.0  \n**Status**: ðŸš§ IN PROGRESS